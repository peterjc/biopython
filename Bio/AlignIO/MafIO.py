# Copyright 2011 by Andrew Sczesnak.  All rights reserved.
# Revisions Copyright 2011 by Peter Cock.  All rights reserved.
#
# This code is part of the Biopython distribution and governed by its
# license.  Please see the LICENSE file that should have been included
# as part of this package.
"""Bio.AlignIO support for the "maf" multiple alignment format.

You are expected to use this module via the Bio.AlignIO functions(or the
Bio.SeqIO functions if you want to work directly with the gapped sequences).

"""
from Bio.Alphabet import single_letter_alphabet
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Align.Generic import Alignment
from Bio.Align import MultipleSeqAlignment
from Interfaces import SequentialAlignmentWriter

class MafWriter(SequentialAlignmentWriter):
    """Accepts a MultipleSeqAlignment object, writes a MAF file.
    
    More later.
    """
    
    def write_header(self):
        self.handle.write ("##maf version=1 scoring=none\n")
        self.handle.write ("# generated by Biopython\n\n")

    def _write_record (self, record):
        fields = ["s",
                  #In the MAF file format, spaces are not allowed in the id
                  "%-40s" % record.id.replace(" ","_"),
                  "%15s" % record.annotations.get("start", 0),
                  "%5s" % record.annotations.get("size", len(str(record.seq).replace("-",""))),
                  record.annotations.get("strand", "+"),
                  "%15s" % record.annotations.get("srcSize", 0),
                  str(record.seq)]
        self.handle.write(" ".join(fields) + "\n")

    def write_alignment(self, alignment):
        if not isinstance(alignment, Alignment):
            raise TypeError("Expected an alignment object")
        
        if len(set([len(x) for x in alignment])) > 1:
            raise ValueError("Sequences must all be the same length")

        all_ids = [x.id for x in alignment]

        if len(all_ids) != len(set(all_ids)):
            raise ValueError("Identifiers in each MultipleSeqAlignment must be unique")

        # for now, use ._annotations private property, but restrict keys to those
        # specifically supported by the MAF format, according to spec
        try:
            anno = " ".join(["%s=%s" % (x, y) for x, y in alignment._annotations.iteritems() if x in ("score", "pass")])
        except AttributeError:
            anno = "score=0.00"

        self.handle.write("a %s\n" % (anno,))

        recs_out = 0

        for record in alignment:
            self._write_record(record)

            recs_out += 1

        self.handle.write("\n")

        return recs_out


def MafIterator(handle, seq_count=None, alphabet=single_letter_alphabet):
    """MAF alignment parser, to be called via the Bio.AlignIO API."""
    annotations = {}
    records = []
    for line in handle:
        #Put most common test first
        if line[:2] == "s ":
            #src (ID), start, size, strand, srcSize, text (sequence)
            fields = line[2:].strip().split()
            anno = {"start": int(fields[1]),
                    "strand": fields[3],
                    "size": int(fields[2]),
                    "srcSize": int(fields[4])}
            sequence = fields[5]
            #Interpret a dot/period to mean same the first sequence
            if "." in sequence:
                if not records:
                    raise ValueError("Found dot/period in first sequence of alignment")
                ref = str(records[0].seq)
                new = []
                for (s, r) in zip(sequence, ref):
                    if s == ".":
                        new.append(r)
                    else:
                        new.append(s)
                sequence = "".join(new)
            records.append(SeqRecord(Seq(sequence, alphabet),
                                     id=fields[0],
                                     name=fields[0],
                                     description="",
                                     annotations=anno))
        elif line[0] == "a":
            #New alignment, return any old one
            if records:
                if seq_count is not None:
                    assert len(records) == seq_count
                alignment = MultipleSeqAlignment(records, alphabet)
                #TODO - Introduce an annotated alignment class?
                #See also Bio/AlignIO/FastaIO.py for same requirement.        
                #For now, store the annotation a new private property:
                alignment._annotations = annotations
                yield alignment
            #Reset ready for the new alignment
            records = []
            annotations = dict(x.split("=") for x in line[1:].strip().split())
        elif line[0] == "#" or not line.strip():
            #Ignore comments or blank lines
            pass
        elif line.startswith("e ") \
        or line.startswith("i ") \
        or line.startswith("q "):
            #Not implemented yet
            pass
        elif line.startswith("track "):
            #Should really only be the first line of the file... check this?
            pass
        else:
            raise ValueError('Unexpected line:\n%s' % line)
    #End of the file
    if records:
        #Don't forget the final alignment!
        if seq_count is not None:
            assert len(records) == seq_count
        alignment = MultipleSeqAlignment(records, alphabet)
        alignment._annotations = annotations
        yield alignment

